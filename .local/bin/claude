#!/bin/bash
# Direct container wrapper for Claude Code
# This avoids tsx/node_modules dependencies

set -e

# Load shared environment loader
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/../lib/env-loader.sh"

# Load environment automatically
load_project_env

# PID file for tracking watch processes
WATCH_PID_FILE="/tmp/apm-watch-processes.pid"

CONTAINER_NAME="apm-workspace"
CONTAINER_IMAGE="apm-claude-container:latest"

# Get current directory relative to project root
WORK_DIR="/workspace"
if [ -n "$PWD" ]; then
    # Find project root (prioritize main/worktrees structure)
    PROJECT_ROOT="$PWD"
    FOUND_ROOT=""
    
    # First pass: look for main/worktrees structure with proper validation
    TEMP_ROOT="$PWD"
    while [ "$TEMP_ROOT" != "/" ]; do
        if [ -d "$TEMP_ROOT/main" ] && [ -d "$TEMP_ROOT/worktrees" ] && [ -f "$TEMP_ROOT/main/package.json" ] && [ -d "$TEMP_ROOT/main/apm" ]; then
            FOUND_ROOT="$TEMP_ROOT"
            break
        fi
        TEMP_ROOT="${TEMP_ROOT%/*}"
        [ "$TEMP_ROOT" = "" ] && TEMP_ROOT="/"
    done
    
    # If not found, second pass: look for other valid structures
    if [ -z "$FOUND_ROOT" ]; then
        TEMP_ROOT="$PWD"
        while [ "$TEMP_ROOT" != "/" ]; do
            if [ -f "$TEMP_ROOT/main/package.json" ] && [ -d "$TEMP_ROOT/main/apm" ]; then
                FOUND_ROOT="$TEMP_ROOT"
                break
            elif [ -f "$TEMP_ROOT/package.json" ] && [ -d "$TEMP_ROOT/apm" ]; then
                FOUND_ROOT="$TEMP_ROOT"
                break
            fi
            TEMP_ROOT="${TEMP_ROOT%/*}"
        [ "$TEMP_ROOT" = "" ] && TEMP_ROOT="/"
        done
    fi
    
    if [ -n "$FOUND_ROOT" ]; then
        PROJECT_ROOT="$FOUND_ROOT"
    fi
    
    if [ "$PROJECT_ROOT" != "/" ]; then
        REL_PATH="${PWD#$PROJECT_ROOT}"
        if [ -n "$REL_PATH" ]; then
            WORK_DIR="/workspace$REL_PATH"
        fi
    fi
fi

# Detect host OS
detect_host_os() {
    case "$(uname -s)" in
        Darwin*) echo "darwin" ;;
        Linux*)  echo "linux" ;;
        MINGW*|MSYS*|CYGWIN*) echo "windows" ;;
        *)       echo "unknown" ;;
    esac
}

# Setup X11 for clipboard support
setup_x11_environment() {
    local host_os=$(detect_host_os)
    
    case "$host_os" in
        darwin)
            # Check if XQuartz is installed
            if [ -d "/Applications/Utilities/XQuartz.app" ] || [ -d "/Applications/XQuartz.app" ]; then
                # Start XQuartz if not running
                if ! pgrep -x "XQuartz" > /dev/null; then
                    echo "üñ•Ô∏è  Starting XQuartz for clipboard support..."
                    open -a XQuartz &
                    sleep 2
                fi
                # Set DISPLAY if not already set
                [ -z "$DISPLAY" ] && export DISPLAY=":0"
                # Allow connections from Docker
                xhost +localhost 2>/dev/null || true
            else
                echo "‚ö†Ô∏è  XQuartz not found. Install it for clipboard support: brew install --cask xquartz"
            fi
            ;;
        linux)
            # Set DISPLAY if not already set
            [ -z "$DISPLAY" ] && export DISPLAY=":0"
            # Allow local connections
            xhost +local:docker 2>/dev/null || true
            ;;
    esac
    
    export HOST_OS="$host_os"
}

# Function to start watch processes on host if not already running
start_watch_processes() {
    if [ -f "$WATCH_PID_FILE" ]; then
        WATCH_PID=$(cat "$WATCH_PID_FILE" 2>/dev/null || echo "")
        if [ -n "$WATCH_PID" ] && kill -0 "$WATCH_PID" 2>/dev/null; then
            echo "üìã Watch processes already running (PID: $WATCH_PID)"
            return 0
        else
            echo "üîÑ Cleaning up stale PID file..."
            rm -f "$WATCH_PID_FILE"
        fi
    fi
    
    echo "üöÄ Starting watch processes on host..."
    cd "$PROJECT_ROOT"
    nohup pnpm start > /tmp/apm-watch.log 2>&1 &
    WATCH_PID=$!
    echo "$WATCH_PID" > "$WATCH_PID_FILE"
    echo "‚úÖ Watch processes started (PID: $WATCH_PID, logs: /tmp/apm-watch.log)"
}

# Setup X11 environment for clipboard support
setup_x11_environment

# Start watch processes before container
start_watch_processes

# Check clipboard service availability (non-blocking)
check_clipboard_service() {
    if [ "${APM_CLIPBOARD_BRIDGE:-true}" = "false" ]; then
        return 0
    fi
    
    # Quick check without waiting - if it's ready, great, if not, continue
    if curl -s --connect-timeout 1 "http://localhost:41073/health" > /dev/null 2>&1; then
        echo "‚úÖ Clipboard service available"
    else
        echo "‚ÑπÔ∏è  Clipboard service not available (will start with watch processes)"
    fi
}

check_clipboard_service

# Check if container exists and is running
if ! docker ps --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
    echo "Starting APM container..."
    
    # Ensure container is stopped if it exists
    docker rm -f "$CONTAINER_NAME" 2>/dev/null || true
    
    # Prepare X11 configuration for clipboard support
    X11_CONFIG=""
    if [ -n "$DISPLAY" ] && [ -S "/tmp/.X11-unix" ]; then
        X11_CONFIG="-e DISPLAY=$DISPLAY -v /tmp/.X11-unix:/tmp/.X11-unix:rw"
        if [ -f "$HOME/.Xauthority" ]; then
            X11_CONFIG="$X11_CONFIG -v $HOME/.Xauthority:/home/user/.Xauthority:rw"
        fi
        # Add security options for clipboard access
        X11_CONFIG="$X11_CONFIG --security-opt seccomp:unconfined"
    fi
    
    # Start new container with restricted access
    docker run -d \
        --name "$CONTAINER_NAME" \
        --restart unless-stopped \
        --user "$(id -u):$(id -g)" \
        -v "$PROJECT_ROOT:/workspace" \
        -v "$HOME/.claude.json:/home/user/.claude.json" \
        -v "$HOME/.claude:/home/user/.claude" \
        -e "HOME=/home/user" \
        -e "APM_CONTAINERIZED=${APM_CONTAINERIZED:-true}" \
        -e "APM_SECURITY_LEVEL=${APM_SECURITY_LEVEL:-standard}" \
        -e "APM_DEBUG=${APM_DEBUG:-false}" \
        -e "GH_TOKEN=${GITHUB_BOT_TOKEN:-$GITHUB_TOKEN}" \
        -e "GITHUB_TOKEN=${GITHUB_BOT_TOKEN:-$GITHUB_TOKEN}" \
        -e "PATH=/workspace/.local/bin:/workspace/node_modules/.bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin" \
        -e "HOST_OS=${HOST_OS:-}" \
        $X11_CONFIG \
        "$CONTAINER_IMAGE"
    
    # Wait for container to be ready
    echo "Waiting for container to be healthy..."
    for i in {1..20}; do
        if docker ps --filter "name=$CONTAINER_NAME" --filter "health=healthy" --format '{{.Names}}' | grep -q "$CONTAINER_NAME"; then
            echo "‚úÖ Container is healthy"
            break
        fi
        sleep 2
    done
fi

# Determine if we need interactive mode
EXEC_FLAGS=""
if [ -t 0 ] && [ -t 1 ]; then
    EXEC_FLAGS="-it"
fi

# Execute Claude in container
echo "üê≥ Executing Claude Code within Docker container '$CONTAINER_NAME'"
echo "üìÅ Working directory: $WORK_DIR"
echo "üë§ Agent role: ${APM_AGENT_ROLE:-developer}"
echo "üåø Worktree: $(basename "$PWD")"
echo ""

exec docker exec $EXEC_FLAGS \
    -w "$WORK_DIR" \
    -e "APM_AGENT_ROLE=${APM_AGENT_ROLE:-developer}" \
    -e "APM_WORKTREE_NAME=$(basename "$PWD")" \
    -e "PATH=/workspace/.local/bin:/workspace/node_modules/.bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin" \
    "$CONTAINER_NAME" \
    /usr/local/bin/claude --dangerously-skip-permissions "$@"